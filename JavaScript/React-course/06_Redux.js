/* REDUX */

/* Чтобы каждый раз не перебрасывать состояние или изменение состояние через пропсы - можно вынести состояние в отдельное хранилище в которое можно получить доступ из любых компонентов */

/* Лучше использовать локальное состояние если оно нужно только в одном компоненте */

/* 
State - неизменяемый обьект. Состояние изменить нельзя но можно сделать новое состояние 
Reducer - создает новое состояние (не изменяет существующее)
Store - глобальное хранилище где находится state и reducer
Action - обьект js в котором должно быть свойство type

{type: 'ADD_TODO,
//если нужно добавить информацию о действии используется payload
payload: {
	id: 1,
	text: 'Dima',
	isCompleted: false
}}


*/

/* Обновление состояния в Redux :
Action => Reducer => State

При обработке Action возвращает НОВОЕ состояние (изменять текущее состояние ЗАПРЕЩЕНО)


 */

/* PURE FUNCTION */
/* 
1. Это функция которая является предсказуемой,  она всегда возвращает один и тот же результат при тех же вводных аргументах 
2. Она не изменяет внешние переменные
3. Не зависит от внешних переменных и состояния программы
4. Не взаимодействует с внешними ресурсами (база данных / интернет и тд)

Reducer - чистая функция
*/

/* 
Принцип работы Redux: 
1.Компоненты отправляют действие (обьект со свойством type) в reducer используя dispatch
2.Reducer берет старое сосоятояние и делает на основе старого состяния и переданного дейсвтия НОВОЕ состояние 
3.Благодаря подписке на состояние (subscribe) компоненты узнают о появлении НОВОГО состояния (можно подписаться на определенные части всего состояния)*/

/* 
ПРЕИМУЩЕСТВА REDUX:
1. Централизированное управление состояния
2. Масштабируемость 
3. Предсказуемое обновление состояния
4. Эффективная коммуникация между компонентами
5. Упращенная отладка приложение (проще находить ошибки) */

//Пример reducer (чистая функция)
const reducer = (state, action) => {
	const { type, payload } = action
	if (type === 'ADD_TODO') {
		return {
			...state,
			todos: [...state.todos, payload],
		}
	}
	return state
}

//reducer через switch:
const switchReducer = (state, action) => {
	const { type, payload } = action
	switch (type) {
		case 'ADD_TODO':
			return {
				...state,
				todos: [...state.todos, payload],
			}

		default:
			return state
	}
}

/* Redux создает текущее состояние на основании начального состояния и последовательности действий */
/* Зная начальное состояние и все дейсвтия которые были совершены то можно восстановить любое состояние приложения в прошлом */

function sum() {
	let count = 0
	function increment() {
		count++
		return count
	}
	function decrement() {
		count--
		return count
	}
	return {
		count,
		increment,
		decrement,
	}
}
console.log(sum())

const result = sum()
console.log(result.increment())
console.log(result.increment())
